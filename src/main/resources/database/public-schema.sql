CREATE SCHEMA IF NOT EXISTS public;

CREATE EXTENSION IF NOT EXISTS pgroonga;
CREATE EXTENSION IF NOT EXISTS pg_cron;

DO 'BEGIN IF NOT EXISTS ( SELECT 1 FROM pg_type WHERE typname = ''user_provider_enum'' ) THEN CREATE TYPE user_provider_enum AS ENUM (''LOCAL'',''GOOGLE'',''GITHUB''); END IF; END' LANGUAGE plpgsql;
DO 'BEGIN IF NOT EXISTS ( SELECT 1 FROM pg_type WHERE typname = ''user_role_enum'' ) THEN CREATE TYPE user_role_enum AS ENUM (''MEMBER'',''ADMIN'',''BOT''); END IF; END' LANGUAGE plpgsql;
CREATE TABLE IF NOT EXISTS public.users
(
    id            bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email         varchar(255)       NOT NULL UNIQUE,
    username      varchar(12)        NOT NULL UNIQUE,
    nickname      varchar(12)        NOT NULL,
    readme        text               NOT NULL DEFAULT '',
    email_visible boolean            NOT NULL DEFAULT FALSE,
    star_visible  boolean            NOT NULL DEFAULT TRUE,
    provider      user_provider_enum NOT NULL DEFAULT 'LOCAL',
    role          user_role_enum     NOT NULL DEFAULT 'MEMBER',
    created_at    timestamp(6)       NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at    timestamp(6)       NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS public.topics
(
    id             bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    slug           varchar(50)  NOT NULL UNIQUE,
    name           varchar(50)  NOT NULL UNIQUE,
    description    varchar(255) NOT NULL DEFAULT '',
    trending_score integer      NOT NULL DEFAULT 0,
    created_at     timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at     timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX IF NOT EXISTS topics_trending_idx ON public.topics (trending_score DESC);

CREATE TABLE IF NOT EXISTS public.articles
(
    id              bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    slug            varchar(50)  NOT NULL,
    title           text         NOT NULL,
    content         text         NOT NULL,
    thumbnail       varchar(255) NOT NULL DEFAULT 'default/thumbnail.webp',
    star_count      integer      NOT NULL DEFAULT 0,
    comment_count   integer      NOT NULL DEFAULT 0,
    trending_score  integer      NOT NULL DEFAULT 0,
    created_at      timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    writer_id       bigint       NOT NULL
        CONSTRAINT articles_writer_id_fk REFERENCES public.users ON DELETE CASCADE,
    writer_username varchar(12)  NOT NULL,            -- for search(denormalization)
    topics_flat     text         NOT NULL DEFAULT '', -- for search(denormalization)
    CONSTRAINT articles_composite_key_idx UNIQUE (writer_username, slug)
);
CREATE INDEX IF NOT EXISTS articles_search_idx ON public.articles USING pgroonga ((ARRAY [title, content, writer_username, topics_flat])) WITH (tokenizer='TokenMecab');
CREATE INDEX IF NOT EXISTS articles_created_idx ON public.articles (created_at);
CREATE INDEX IF NOT EXISTS articles_trending_idx ON public.articles (trending_score DESC);
CREATE INDEX IF NOT EXISTS articles_writer_id_idx ON public.articles (writer_id);

CREATE TABLE IF NOT EXISTS public.article_topics
(
    id         bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    article_id bigint NOT NULL
        CONSTRAINT article_topics_article_id_fk REFERENCES public.articles ON DELETE CASCADE,
    topic_id   bigint NOT NULL
        CONSTRAINT article_topics_topic_id_fk REFERENCES public.topics ON DELETE CASCADE,
    UNIQUE (article_id, topic_id)
);

CREATE TABLE IF NOT EXISTS public.article_comments
(
    id          bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content     varchar(512) NOT NULL,
    deleted     boolean      NOT NULL DEFAULT FALSE,
    reply_count integer      NOT NULL DEFAULT 0,
    created_at  timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at  timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    article_id  bigint       NOT NULL
        CONSTRAINT article_comments_article_id_fk REFERENCES public.articles ON DELETE CASCADE,
    parent_id   bigint
        CONSTRAINT article_comments_parent_id_fk REFERENCES public.article_comments ON DELETE SET NULL,
    mention_id  bigint
        CONSTRAINT article_comments_mention_id_fk REFERENCES public.users ON DELETE CASCADE,
    writer_id   bigint       NOT NULL
        CONSTRAINT article_comments_writer_id_fk REFERENCES public.users ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS article_comments_article_id_created_idx ON public.article_comments (article_id, created_at DESC);

CREATE TABLE IF NOT EXISTS public.books
(
    id              bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    slug            varchar(50)  NOT NULL UNIQUE,
    title           text         NOT NULL,
    content         text         NOT NULL DEFAULT '',
    thumbnail       varchar(255) NOT NULL DEFAULT 'default/book-thumbnail.webp',
    star_count      integer      NOT NULL DEFAULT 0,
    review_count    integer      NOT NULL DEFAULT 0,
    trending_score  integer      NOT NULL DEFAULT 0,
    created_at      timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    writer_id       bigint       NOT NULL
        CONSTRAINT books_writer_id_fk REFERENCES public.users ON DELETE CASCADE,
    writer_username varchar(12)  NOT NULL,            -- for search(denormalization)
    topics_flat     text         NOT NULL DEFAULT '', -- for search(denormalization),
    CONSTRAINT books_composite_key_idx UNIQUE (writer_username, slug)
);
CREATE INDEX IF NOT EXISTS books_search_idx ON public.books USING pgroonga ((ARRAY [title, content, writer_username, topics_flat])) WITH (tokenizer='TokenMecab');
CREATE INDEX IF NOT EXISTS books_created_idx ON public.books (created_at);
CREATE INDEX IF NOT EXISTS books_trending_idx ON public.books (trending_score DESC);
CREATE INDEX IF NOT EXISTS books_writer_id_idx ON public.books (writer_id);

CREATE TABLE IF NOT EXISTS public.book_chapters
(
    id         bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title      text         NOT NULL,
    content    text         NOT NULL,
    sequence   integer      NOT NULL,
    created_at timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    book_id    bigint       NOT NULL
        CONSTRAINT book_chapters_book_id_fk REFERENCES public.books ON DELETE CASCADE,
    writer_id  bigint       NOT NULL
        CONSTRAINT book_chapters_writer_id_fk REFERENCES public.users ON DELETE CASCADE,
    CONSTRAINT book_chapters_sequence_idx UNIQUE (book_id, sequence) DEFERRABLE INITIALLY DEFERRED
);
CREATE INDEX IF NOT EXISTS book_chapters_book_id_sequence_idx ON public.book_chapters (book_id, sequence ASC);

CREATE TABLE IF NOT EXISTS public.book_topics
(
    id       bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    book_id  bigint NOT NULL
        CONSTRAINT book_topics_book_id_fk REFERENCES public.books ON DELETE CASCADE,
    topic_id bigint NOT NULL
        CONSTRAINT book_topics_topic_id_fk REFERENCES public.topics ON DELETE CASCADE,
    UNIQUE (book_id, topic_id)
);

CREATE TABLE IF NOT EXISTS public.book_reviews
(
    id         bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content    varchar(512) NOT NULL,
    rating     integer      NOT NULL CHECK (rating >= 1 AND rating <= 5),
    created_at timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    book_id    bigint       NOT NULL
        CONSTRAINT book_reviews_book_id_fk REFERENCES public.books ON DELETE CASCADE,
    writer_id  bigint       NOT NULL
        CONSTRAINT book_reviews_writer_id_fk REFERENCES public.users ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS book_reviews_book_id_created_idx ON public.book_reviews (book_id, created_at DESC);

DO 'BEGIN IF NOT EXISTS ( SELECT 1 FROM pg_type WHERE typname = ''question_status_enum'' ) THEN CREATE TYPE question_status_enum AS ENUM (''OPEN'', ''CLOSED'', ''SOLVED''); END IF; END' LANGUAGE plpgsql;
CREATE TABLE IF NOT EXISTS public.questions
(
    id              bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    slug            varchar(50)          NOT NULL,
    title           text                 NOT NULL,
    content         text                 NOT NULL,
    status          question_status_enum NOT NULL DEFAULT 'OPEN',
    solved_at       timestamp(6),                             -- NULL if status is not SOLVED
    closed_at       timestamp(6),                             -- NULL if status is not CLOSED
    star_count      integer              NOT NULL DEFAULT 0,
    answer_count    integer              NOT NULL DEFAULT 0,
    trending_score  integer              NOT NULL DEFAULT 0,
    created_at      timestamp(6)         NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      timestamp(6)         NOT NULL DEFAULT CURRENT_TIMESTAMP,
    writer_id       bigint               NOT NULL
        CONSTRAINT questions_writer_id_fk REFERENCES public.users ON DELETE CASCADE,
    writer_username varchar(12)          NOT NULL,            -- for search(denormalization)
    topics_flat     text                 NOT NULL DEFAULT '', -- for search(denormalization)
    CONSTRAINT questions_composite_key_idx UNIQUE (writer_username, slug)
);
CREATE INDEX IF NOT EXISTS questions_search_idx ON public.questions USING pgroonga ((ARRAY [title, content, writer_username, topics_flat])) WITH (tokenizer='TokenMecab');
CREATE INDEX IF NOT EXISTS questions_created_idx ON public.questions (created_at);
CREATE INDEX IF NOT EXISTS questions_trending_idx ON public.questions (trending_score DESC);
CREATE INDEX IF NOT EXISTS questions_writer_id_idx ON public.questions (writer_id);
CREATE INDEX IF NOT EXISTS questions_status_idx ON public.questions (status);

CREATE TABLE IF NOT EXISTS public.question_topics
(
    id          bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_id bigint NOT NULL
        CONSTRAINT question_topics_question_id_fk REFERENCES public.questions ON DELETE CASCADE,
    topic_id    bigint NOT NULL
        CONSTRAINT question_topics_topic_id_fk REFERENCES public.topics ON DELETE CASCADE,
    UNIQUE (question_id, topic_id)
);

CREATE TABLE IF NOT EXISTS public.question_answers
(
    id          bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content     text         NOT NULL,
    accepted    boolean      NOT NULL DEFAULT FALSE,
    accepted_at timestamp(6),
    created_at  timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at  timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    question_id bigint       NOT NULL
        CONSTRAINT question_answers_question_id_fk REFERENCES public.questions ON DELETE CASCADE,
    writer_id   bigint       NOT NULL
        CONSTRAINT question_answers_writer_id_fk REFERENCES public.users ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS question_answers_question_id_created_idx ON public.question_answers (question_id, created_at ASC);

DO 'BEGIN IF NOT EXISTS ( SELECT 1 FROM pg_type WHERE typname = ''star_target_enum'' ) THEN CREATE TYPE star_target_enum AS ENUM (''ARTICLE'',''BOOK'',''QUESTION''); END IF; END' LANGUAGE plpgsql;
CREATE TABLE IF NOT EXISTS public.stars
(
    id          bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    target      star_target_enum NOT NULL,
    created_at  timestamp(6)     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    article_id  bigint
        CONSTRAINT stars_article_id_fk REFERENCES public.articles ON DELETE CASCADE,
    book_id     bigint
        CONSTRAINT stars_book_id_fk REFERENCES public.books ON DELETE CASCADE,
    question_id bigint
        CONSTRAINT stars_question_id_fk REFERENCES public.questions ON DELETE CASCADE,
    user_id     bigint           NOT NULL
        CONSTRAINT stars_user_id_fk REFERENCES public.users ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS stars_user_id_created_at_idx ON public.stars (user_id, created_at DESC);

CREATE TABLE IF NOT EXISTS public.search_synonyms
(
    term     TEXT PRIMARY KEY,
    synonyms TEXT[]
);

CREATE OR REPLACE VIEW user_posts AS
SELECT ('@' || writer_username || '/articles/' || slug) AS path,
       NULL::question_status_enum                       AS question_status,
       updated_at,
       writer_id
FROM articles
UNION ALL
SELECT ('@' || writer_username || '/books/' || slug) AS path,
       NULL::question_status_enum                    AS question_status,
       updated_at,
       writer_id
FROM books
UNION ALL
SELECT ('@' || writer_username || '/questions/' || slug) AS path, status AS question_status, updated_at, writer_id
FROM questions;
CREATE INDEX IF NOT EXISTS articles_writer_updated_idx ON articles (writer_id, updated_at DESC) INCLUDE (slug, title, writer_username);
CREATE INDEX IF NOT EXISTS books_writer_updated_idx ON books (writer_id, updated_at DESC) INCLUDE (slug, title, writer_username);
CREATE INDEX IF NOT EXISTS questions_writer_updated_idx ON questions (writer_id, updated_at DESC) INCLUDE (slug, title, status, writer_username);

CREATE OR REPLACE FUNCTION public.update_topics_trending_score() RETURNS void
    LANGUAGE plpgsql AS
'
    DECLARE
    BEGIN
        UPDATE topics SET trending_score = 0, updated_at = CURRENT_TIMESTAMP WHERE trending_score IS NOT NULL;
        WITH per_topic AS ( SELECT at.topic_id, SUM(a.trending_score) AS score
                            FROM public.article_topics at
                                     LEFT JOIN public.articles a ON a.id = at.article_id
                            WHERE a.created_at >= CURRENT_DATE - INTERVAL ''7 days''
                            GROUP BY at.topic_id
                            UNION ALL
                            SELECT bt.topic_id, SUM(b.trending_score) AS score
                            FROM public.book_topics bt
                                     LEFT JOIN public.books b ON b.id = bt.book_id
                            WHERE b.created_at >= CURRENT_DATE - INTERVAL ''7 days''
                            GROUP BY bt.topic_id
                            UNION ALL
                            SELECT qt.topic_id, SUM(q.trending_score) AS score
                            FROM public.question_topics qt
                                     LEFT JOIN public.questions q ON q.id = qt.question_id
                            WHERE q.created_at >= CURRENT_DATE - INTERVAL ''7 days''
                            GROUP BY qt.topic_id ),
             aggregated AS ( SELECT topic_id, SUM(score)::integer AS new_score FROM per_topic GROUP BY topic_id )
        UPDATE public.topics t
        SET trending_score = COALESCE(a.new_score, 0),
            updated_at     = CURRENT_TIMESTAMP
        FROM aggregated a
        WHERE t.id = a.topic_id;
    END;
';

-- 매주 일요일 오전 1시
SELECT cron.schedule('weekly_topic_trending', '0 1 * * 0', $$CALL public.update_topics_trending_score()$$);
